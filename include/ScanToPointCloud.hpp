//
// Created by chazz on 15/12/2021.
//

#pragma once

#include <vector>
#include "R2000/Data.hpp"
#include <pcl/point_cloud.h>

namespace PointCloud {
    /**
 * @brief This class allows to convert raw data incoming from a P&F R2000 sensor to a point cloud for a fixed
 * set of parameters of the sensor.
 * @date 03/02/2020
 */
    template<typename PointT>
    class ScanToPointCloud {

    public:
        /**
         * @brief Construct a new instance of this converter with a given set of parameters used by the P&F sensor.
         * @param N The number of points provided by the sensor for each scan.
         * @param thetaMin The minimal angle between each point of the scan.
         * @param maxRange The maximal range of the points to output to the scanned cloud.
         * @param minRange The minimal range of the points to output to the scanned cloud.
         * @param maxReflectivity The maximal reflectivity of the points to output to the scanned cloud.
         * @param minReflectivity The minimal reflectivity of the points to output to the scanned cloud.
         * @date 03/02/2020
         */
        ScanToPointCloud(const unsigned int N, const float thetaMin)
                : mCosines(new std::vector<float>),
                  mSinuses(new std::vector<float>),
                  nbPoints(N) {
            mCosines->reserve(nbPoints);
            mSinuses->reserve(nbPoints);
            const auto increment = float(2.0f * M_PI / nbPoints);
            for (unsigned int i = 0; i < nbPoints; ++i) {
                const float angle = thetaMin + (increment * float(i));
                sincosf(angle, &((*mSinuses)[i]), &((*mCosines)[i]));
            }
        }

        /**
         * @brief Convert a raw scan from a P&F R2000 to a point cloud. The
         * @param scan the raw scan from the sensor.
         * @param indices Indices of the points kept and inserted into the output cloud.
         * @param cloud Output cloud generated from the raw scan.
         * @date 03/02/2020
         */
        void convert(const Device::Data::Scan &scan,
                     typename pcl::PointCloud<PointT> &cloud) {
            cloud.reserve(nbPoints);
            const auto &distances{scan.getDistances()};
            auto index{0u};
            for (auto &range : distances) {
                if (std::isnan(range))
                    continue;
                PointT point{};
                point.x = float(range) * (*mCosines)[index];
                point.y = float(range) * (*mSinuses)[index];
                point.z = 0.0f;
                cloud.push_back(point);
                ++index;
            }
        }

        /**
         * @brief Trivial Dtor.
         * @date 03/02/2020
         */
        virtual ~ScanToPointCloud() = default;

    private:
        /**
         * Cosines of the points generated by the sensor. Depending on the minimal theta
         * between each point configured on the sensor, every points generated around the sensor
         * lie at a specific angle whose cosine can be looked up in this vector depending on the
         * index of the point.
         */
        std::unique_ptr<std::vector<float>> mCosines; //!< preprocessed cosines
        /**
         * Sinuses of the points generated by the sensor. Depending on the minimal theta
         * between each point configured on the sensor, every points generated around the sensor
         * lie at a specific angle whose sinus can be looked up in this vector depending on the
         * index of the point.
         */
        std::unique_ptr<std::vector<float>> mSinuses; //!< preprocessed sines
        /**
         * Number of point the sensor is parameterized to return for each scan.
         */
        const unsigned int nbPoints;
    };
}
